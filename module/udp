#!/bin/bash

# Chargement du module graphique
source /etc/UDPCustom/module

# Configuration
ADMIN_CONTACT="t.me/joeldata237"
# ICI C'EST IMPORTANT : On pointe vers TON VPS Principal pour la v√©rification
# Tous les clients (amis) viendront v√©rifier leur cl√© ici.
VERIFY_URL="http://76.13.8.245:5000/verify" 
LICENSE_FILE="/etc/udp_pro_active"

# ==================================================
#            FONCTIONS DE BASE (BASH)
# ==================================================

add_user() {
    title "CREATE USER UDP"
    print_center -ama "Create User UDP Custom"
    msg -bar
    msg -ne " Username: " && read user
    if getent passwd $user > /dev/null 2>&1; then
        print_center -verm "User $user already exists"
        enter
        return
    fi
    msg -ne " Password: " && read pass
    msg -ne " Days Duration: " && read days
    
    exp_date=$(date -d "+$days days" +%Y-%m-%d)
    
    useradd -M -s /bin/false -e $exp_date $user
    echo "$user:$pass" | chpasswd
    
    clear
    msg -bar
    print_center -verd "User Created Successfully"
    msg -bar
    msg -ama " üë§ Username  : $user"
    msg -ama " üîë Password  : $pass"
    msg -ama " üõ°Ô∏è Port UDP  : 1-65535"
    msg -ama " üìÖ Expiry    : $exp_date"
    msg -bar
    enter
}

renew_user() {
    title "RENEW USER UDP"
    print_center -ama "Renew User UDP Custom"
    msg -bar
    msg -ne " Username: " && read user
    if ! getent passwd $user > /dev/null 2>&1; then
        print_center -verm "User $user not found"
        enter
        return
    fi
    msg -ne " Days to add: " && read days
    chage -E $(date -d "+$days days" +%Y-%m-%d) $user
    
    new_exp=$(chage -l $user | grep 'Account expires' | cut -d: -f2)
    
    clear
    msg -bar
    print_center -verd "User Renewed Successfully"
    msg -bar
    msg -ama " üë§ Username  : $user"
    msg -ama " üìÖ New Expiry: $new_exp"
    msg -bar
    enter
}

remove_user() {
    title "REMOVE USER UDP"
    print_center -ama "Remove User UDP Custom"
    msg -bar
    msg -ne " Username: " && read user
    if ! getent passwd $user > /dev/null 2>&1; then
        print_center -verm "User $user not found"
        enter
        return
    fi
    userdel -f $user
    msg -bar
    print_center -verd "User $user Removed Successfully"
    msg -bar
    enter
}

list_users() {
    title "LIST USERS UDP"
    print_center -ama "List of Users"
    msg -bar
    echo -e " \033[1;33mUSERNAME \033[1;37m| \033[1;32mEXPIRATION"
    msg -bar
    while read line; do
        u=$(echo $line | cut -d: -f1)
        exp=$(chage -l $u | grep "Account expires" | cut -d: -f2)
        echo -e " \033[1;37m$u \033[1;33m-> \033[1;32m$exp"
    done < <(grep "/bin/false" /etc/passwd)
    enter
}

# ==================================================
#            FONCTIONS PRO+ (BOT CENTRAL V5)
# ==================================================

install_bot_pro() {
  title "ü§ñ INSTALLATION BOT MANAGER & LICENCE"
  msg -azu " Ce bot g√®re vos utilisateurs ET vend des licences."
  msg -bar
  msg -ne " Token Bot (BotFather): " && read token
  msg -ne " ID Admin Telegram: " && read admin_id
  
  vps_ip=$(curl -s ipv4.icanhazip.com)

  msg -verd " Installation des d√©pendances Python (Flask/Telebot)..."
  apt-get install python3-pip at sqlite3 -y > /dev/null 2>&1
  pip3 install pyTelegramBotAPI flask > /dev/null 2>&1

  # --- CR√âATION DU SCRIPT PYTHON (CERVEAU CENTRAL) ---
  cat << 'PYTHON_MARKER' > /etc/UDPCustom/udp_bot.py
import telebot
from telebot import types
from flask import Flask, request
import threading
import os
import subprocess
import random
import string
import datetime
import time
import re
import sqlite3

# --- CONFIGURATION ---
TOKEN = "TOKEN_PLACEHOLDER"
ADMIN_ID = "ADMIN_ID_PLACEHOLDER"
VPS_IP = "IP_PLACEHOLDER"
DB_PATH = "/etc/UDPCustom/bot_data.db"
PORT_API = 5000
# ---------------------

bot = telebot.TeleBot(TOKEN)
app = Flask(__name__)

# --- BASE DE DONN√âES (Users + Licences) ---
def init_db():
    conn = sqlite3.connect(DB_PATH, check_same_thread=False)
    c = conn.cursor()
    # Table des utilisateurs SSH/UDP
    c.execute('''CREATE TABLE IF NOT EXISTS users (username TEXT PRIMARY KEY, password TEXT)''')
    # Table des licences (pour les scripts amis)
    c.execute('''CREATE TABLE IF NOT EXISTS licenses (key_text TEXT PRIMARY KEY, status TEXT, expires_at TIMESTAMP)''')
    conn.commit()
    conn.close()

# -- Gestion Users --
def save_user_db(user, password):
    try:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        c = conn.cursor()
        c.execute("INSERT OR REPLACE INTO users (username, password) VALUES (?, ?)", (user, password))
        conn.commit()
        conn.close()
    except: pass

def get_pass_db(user):
    try:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        c = conn.cursor()
        c.execute("SELECT password FROM users WHERE username=?", (user,))
        res = c.fetchone()
        conn.close()
        return res[0] if res else "Inconnu"
    except: return "Erreur DB"

def del_user_db(user):
    try:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        c = conn.cursor()
        c.execute("DELETE FROM users WHERE username=?", (user,))
        conn.commit()
        conn.close()
    except: pass

# -- Gestion Licences --
def create_license(duration_days):
    key = "KEY-" + ''.join(random.choices(string.ascii_uppercase + string.digits, k=12))
    conn = sqlite3.connect(DB_PATH, check_same_thread=False)
    c = conn.cursor()
    if duration_days == 999: # Vie
        exp = datetime.datetime.max
    else:
        exp = datetime.datetime.now() + datetime.timedelta(days=duration_days)
    
    c.execute("INSERT INTO licenses (key_text, status, expires_at) VALUES (?, ?, ?)", (key, 'active', exp))
    conn.commit()
    conn.close()
    return key, exp

def check_license_db(key):
    conn = sqlite3.connect(DB_PATH, check_same_thread=False)
    c = conn.cursor()
    c.execute("SELECT expires_at FROM licenses WHERE key_text=?", (key,))
    res = c.fetchone()
    conn.close()
    if not res: return False
    
    # V√©rif date
    try:
        exp_date = datetime.datetime.strptime(res[0], "%Y-%m-%d %H:%M:%S.%f")
    except:
        return True # Si format date complexe (ou max), on accepte
        
    if datetime.datetime.now() < exp_date:
        return True
    return False

# --- API FLASK (V√©rification Distante) ---
@app.route('/verify', methods=['GET'])
def verify_api():
    key = request.args.get('key')
    if check_license_db(key):
        return "VALID", 200
    else:
        return "INVALID", 403

def run_flask():
    # Ecoute sur 0.0.0.0 pour accepter les connexions externes (Amis)
    app.run(host='0.0.0.0', port=PORT_API)

# --- OUTILS SYST√àME ---
def run_cmd(cmd):
    return subprocess.getoutput(cmd)

def generate_pass(length=6):
    return ''.join(random.choices(string.ascii_lowercase + string.digits, k=length))

def get_users_list():
    cmd = "awk -F: '/\/bin\/false/ {print $1}' /etc/passwd"
    users = run_cmd(cmd).split('\n')
    return [u for u in users if u]

def get_expiry(user):
    try:
        cmd = f"chage -l {user} | grep 'Account expires' | cut -d: -f2"
        return run_cmd(cmd).strip()
    except: return "Erreur"

def parse_duration(text):
    match = re.match(r"(\d+)([mhd])", text.lower())
    if not match: return None
    val, unit = int(match.group(1)), match.group(2)
    return val, unit

# --- MENU TELEGRAM ---
def main_menu():
    markup = types.InlineKeyboardMarkup(row_width=2)
    # Gestion Users
    b1 = types.InlineKeyboardButton("üë§ Cr√©er User", callback_data='add_wiz')
    b2 = types.InlineKeyboardButton("üë• Liste Users", callback_data='list_menu')
    b3 = types.InlineKeyboardButton("üîÑ Renouveler", callback_data='renew_menu')
    b4 = types.InlineKeyboardButton("‚úèÔ∏è Modifier", callback_data='edit_menu')
    b5 = types.InlineKeyboardButton("üóë Supprimer", callback_data='del_menu')
    # Outils
    b6 = types.InlineKeyboardButton("‚è± Trial", callback_data='trial_menu')
    b7 = types.InlineKeyboardButton("üñ• Infos VPS", callback_data='info')
    # Business (Licences)
    b8 = types.InlineKeyboardButton("üîë G√©rer Licences", callback_data='lic_menu')
    
    markup.add(b1, b2, b3, b4, b5, b6, b7, b8)
    return markup

@bot.message_handler(commands=['start', 'menu'])
def send_welcome(message):
    if str(message.chat.id) == str(ADMIN_ID):
        bot.reply_to(message, "üî∞ **JOEL DATA - CENTRAL SERVER** üî∞\n\nG√©rez vos utilisateurs et vos licences revendeurs :", reply_markup=main_menu(), parse_mode="Markdown")

# --- CALLBACKS ---
@bot.callback_query_handler(func=lambda call: True)
def callback_query(call):
    if str(call.message.chat.id) != str(ADMIN_ID): return

    if call.data == "home":
        bot.edit_message_text("üî∞ **MENU PRINCIPAL** üî∞", call.message.chat.id, call.message.message_id, reply_markup=main_menu(), parse_mode="Markdown")

    # === GESTION LICENCES (BUSINESS) ===
    elif call.data == "lic_menu":
        markup = types.InlineKeyboardMarkup()
        markup.add(types.InlineKeyboardButton("‚ûï Cr√©er Cl√© (30 Jours)", callback_data="gen_key:30"))
        markup.add(types.InlineKeyboardButton("‚ûï Cr√©er Cl√© (√Ä Vie)", callback_data="gen_key:999"))
        markup.add(types.InlineKeyboardButton("üîô Retour", callback_data="home"))
        bot.edit_message_text("üîë **PANEL LICENCES SCRIPT**\nG√©n√©rez des cl√©s pour activer le script PRO+ sur d'autres VPS.", call.message.chat.id, call.message.message_id, reply_markup=markup, parse_mode="Markdown")

    elif call.data.startswith("gen_key:"):
        days = int(call.data.split(":")[1])
        key, exp = create_license(days)
        if days == 999: d_txt = "√Ä Vie"
        else: d_txt = f"{days} Jours"
        
        decor = f"""
‚úÖ **LICENCE G√âN√âR√âE**
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üîë **Cl√© :** `{key}`
üìÖ **Validit√© :** {d_txt}
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
Donnez cette cl√© √† votre ami pour activer le menu PRO+.
"""
        bot.send_message(call.message.chat.id, decor, parse_mode="Markdown")
        bot.send_message(call.message.chat.id, "Menu :", reply_markup=main_menu())

    # === LISTE USERS ===
    elif call.data == "list_menu":
        users = get_users_list()
        markup = types.InlineKeyboardMarkup(row_width=2)
        if not users: markup.add(types.InlineKeyboardButton("Vide", callback_data="home"))
        else:
            for u in users: markup.add(types.InlineKeyboardButton(f"üë§ {u}", callback_data=f"view_user:{u}"))
        markup.add(types.InlineKeyboardButton("üîô Retour", callback_data="home"))
        bot.edit_message_text("üìÇ **Liste Clients :**", call.message.chat.id, call.message.message_id, reply_markup=markup, parse_mode="Markdown")

    # D√âTAILS USER (+ PASS VISIBLE)
    elif call.data.startswith("view_user:"):
        user = call.data.split(":")[1]
        exp = get_expiry(user)
        real_pass = get_pass_db(user)
        format_client = f"{VPS_IP}:1-65535@{user}:{real_pass}"
        
        decor = f"""
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üë§ **D√âTAILS COMPTE**
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üë§ **User :** `{user}`
üîë **Pass :** `{real_pass}`
üìÖ **Expire :** `{exp}`
üõ° **Port :** `1-65535`
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üëá **Format Client :**
`{format_client}`
"""
        markup = types.InlineKeyboardMarkup()
        markup.add(types.InlineKeyboardButton("üîô Liste", callback_data="list_menu"), types.InlineKeyboardButton("üè† Accueil", callback_data="home"))
        bot.edit_message_text(decor, call.message.chat.id, call.message.message_id, parse_mode="Markdown", reply_markup=markup)

    # === SUPPRESSION ===
    elif call.data == "del_menu":
        users = get_users_list()
        markup = types.InlineKeyboardMarkup(row_width=2)
        for u in users: markup.add(types.InlineKeyboardButton(f"‚ùå {u}", callback_data=f"pre_del:{u}"))
        markup.add(types.InlineKeyboardButton("üîô Retour", callback_data="home"))
        bot.edit_message_text("üóë **Supprimer qui ?**", call.message.chat.id, call.message.message_id, reply_markup=markup, parse_mode="Markdown")

    elif call.data.startswith("pre_del:"):
        user = call.data.split(":")[1]
        markup = types.InlineKeyboardMarkup()
        markup.add(types.InlineKeyboardButton("‚úÖ OUI", callback_data=f"do_del:{user}"), types.InlineKeyboardButton("üîô NON", callback_data="del_menu"))
        bot.edit_message_text(f"‚ö†Ô∏è Supprimer `{user}` ?", call.message.chat.id, call.message.message_id, parse_mode="Markdown", reply_markup=markup)

    elif call.data.startswith("do_del:"):
        user = call.data.split(":")[1]
        os.system(f"userdel -f {user}")
        del_user_db(user)
        markup = types.InlineKeyboardMarkup()
        markup.add(types.InlineKeyboardButton("üîô Retour", callback_data="home"))
        bot.edit_message_text(f"‚úÖ `{user}` supprim√©.", call.message.chat.id, call.message.message_id, parse_mode="Markdown", reply_markup=markup)

    # === RENOUVELLEMENT ===
    elif call.data == "renew_menu":
        users = get_users_list()
        markup = types.InlineKeyboardMarkup(row_width=2)
        for u in users: markup.add(types.InlineKeyboardButton(f"üîÑ {u}", callback_data=f"renew_wiz:{u}"))
        markup.add(types.InlineKeyboardButton("üîô Retour", callback_data="home"))
        bot.edit_message_text("üîÑ **Renouveler qui ?**", call.message.chat.id, call.message.message_id, reply_markup=markup, parse_mode="Markdown")

    elif call.data.startswith("renew_wiz:"):
        user = call.data.split(":")[1]
        msg = bot.send_message(call.message.chat.id, f"üë§ **User:** `{user}`\nEntrez la dur√©e (ex: `10d`, `1h`) :", parse_mode="Markdown")
        bot.register_next_step_handler(msg, step_renew_process, user)

    # === MODIFIER ===
    elif call.data == "edit_menu":
        users = get_users_list()
        markup = types.InlineKeyboardMarkup(row_width=2)
        for u in users: markup.add(types.InlineKeyboardButton(f"‚úèÔ∏è {u}", callback_data=f"edit_start:{u}"))
        markup.add(types.InlineKeyboardButton("üîô Retour", callback_data="home"))
        bot.edit_message_text("‚úèÔ∏è **Modifier qui ?**", call.message.chat.id, call.message.message_id, reply_markup=markup, parse_mode="Markdown")

    elif call.data.startswith("edit_start:"):
        user = call.data.split(":")[1]
        msg = bot.send_message(call.message.chat.id, f"üìù Modif `{user}`\nEntrez **NOUVEAU NOM** (ou 'meme') :", parse_mode="Markdown")
        bot.register_next_step_handler(msg, step_edit_name, user)

    # === TRIAL & ADD ===
    elif call.data == "trial_menu":
        markup = types.InlineKeyboardMarkup()
        markup.add(types.InlineKeyboardButton("‚è± 30 Min", callback_data="trial:30"), types.InlineKeyboardButton("‚è± 1 H", callback_data="trial:60"), types.InlineKeyboardButton("üîô Retour", callback_data="home"))
        bot.edit_message_text("‚è≥ Dur√©e du test :", call.message.chat.id, call.message.message_id, reply_markup=markup)

    elif call.data.startswith("trial:"):
        mins = int(call.data.split(":")[1])
        user = "test" + ''.join(random.choices(string.digits, k=4))
        pwd = generate_pass(4)
        os.system(f"useradd -M -s /bin/false {user}")
        os.system(f"echo '{user}:{pwd}' | chpasswd")
        os.system(f"echo 'userdel -f {user}' | at now + {mins} minutes")
        save_user_db(user, pwd)
        format_client = f"{VPS_IP}:1-65535@{user}:{pwd}"
        decor = f"‚úÖ **TRIAL {mins} MIN**\nüë§ `{user}`\nüîë `{pwd}`\n\n`{format_client}`"
        bot.send_message(call.message.chat.id, decor, parse_mode="Markdown")
        bot.send_message(call.message.chat.id, "Menu:", reply_markup=main_menu())

    elif call.data == "add_wiz":
        msg = bot.send_message(call.message.chat.id, "üë§ **Nom d'utilisateur** :", parse_mode="Markdown")
        bot.register_next_step_handler(msg, step_name)

    elif call.data == "info":
        ram = run_cmd("free -m | awk 'NR==2{printf \"%.2f%%\", $3*100/$2 }'")
        bot.answer_callback_query(call.id, f"IP: {VPS_IP} | RAM: {ram}", show_alert=True)

# --- STEPS ---
def step_name(message):
    user = message.text
    msg = bot.send_message(message.chat.id, f"User: `{user}`\nüîë **Mot de Passe** :", parse_mode="Markdown")
    bot.register_next_step_handler(msg, step_pass, user)

def step_pass(message, user):
    pwd = message.text
    msg = bot.send_message(message.chat.id, f"Pass: `{pwd}`\nüìÖ **Jours** :", parse_mode="Markdown")
    bot.register_next_step_handler(msg, step_days, user, pwd)

def step_days(message, user, pwd):
    try:
        days = int(message.text)
        os.system(f"useradd -M -s /bin/false -e $(date -d '+{days} days' +%Y-%m-%d) {user}")
        os.system(f"echo '{user}:{pwd}' | chpasswd")
        save_user_db(user, pwd)
        format_client = f"{VPS_IP}:1-65535@{user}:{pwd}"
        decor = f"‚úÖ **CR√â√â**\nüë§ `{user}`\nüîë `{pwd}`\nüìÖ `{days}j`\n\n`{format_client}`"
        bot.send_message(message.chat.id, decor, parse_mode="Markdown", reply_markup=main_menu())
    except: bot.send_message(message.chat.id, "‚ùå Erreur dur√©e.")

def step_renew_process(message, user):
    res = parse_duration(message.text)
    if not res: return bot.send_message(message.chat.id, "‚ùå Erreur format (ex: 30d)")
    val, unit = res
    if unit == 'd': os.system(f"chage -E $(date -d '+{val} days' +%Y-%m-%d) {user}")
    elif unit == 'h': os.system(f"echo 'userdel -f {user}' | at now + {val} hours")
    elif unit == 'm': os.system(f"echo 'userdel -f {user}' | at now + {val} minutes")
    bot.send_message(message.chat.id, f"‚úÖ `{user}` renouvel√©.", parse_mode="Markdown", reply_markup=main_menu())

def step_edit_name(message, old_user):
    new = message.text
    final = old_user
    if new.lower() != "meme":
        os.system(f"usermod -l {new} {old_user}")
        old_p = get_pass_db(old_user)
        del_user_db(old_user)
        save_user_db(new, old_p)
        final = new
    msg = bot.send_message(message.chat.id, f"User: `{final}`\nüîë **NOUVEAU PASS** (ou 'meme') :", parse_mode="Markdown")
    bot.register_next_step_handler(msg, step_edit_pass, final)

def step_edit_pass(message, user):
    new = message.text
    final_p = new
    if new.lower() != "meme":
        os.system(f"echo '{user}:{new}' | chpasswd")
        save_user_db(user, new)
    else: final_p = get_pass_db(user)
    msg = bot.send_message(message.chat.id, f"Pass: `{final_p}`\nüìÖ **NOUVELLE DUR√âE** (jours ou 'meme') :", parse_mode="Markdown")
    bot.register_next_step_handler(msg, step_edit_final, user, final_p)

def step_edit_final(message, user, pwd):
    if message.text.lower() != "meme":
        try: os.system(f"chage -E $(date -d '+{message.text} days' +%Y-%m-%d) {user}")
        except: pass
    format_client = f"{VPS_IP}:1-65535@{user}:{pwd}"
    bot.send_message(message.chat.id, f"‚úÖ **MODIFI√â**\n`{format_client}`", parse_mode="Markdown", reply_markup=main_menu())

# --- LANCEMENT MULTI-THREAD ---
if __name__ == '__main__':
    init_db()
    # Thread Flask (API)
    t = threading.Thread(target=run_flask)
    t.start()
    # Main Bot
    print("Bot & API Started...")
    bot.polling(non_stop=True)
PYTHON_MARKER

  # Injection des variables BASH dans le fichier PYTHON
  sed -i "s/TOKEN_PLACEHOLDER/$token/g" /etc/UDPCustom/udp_bot.py
  sed -i "s/ADMIN_ID_PLACEHOLDER/$admin_id/g" /etc/UDPCustom/udp_bot.py
  sed -i "s/IP_PLACEHOLDER/$vps_ip/g" /etc/UDPCustom/udp_bot.py

  # Cr√©ation du service
  cat << 'SERVICE_MARKER' > /etc/systemd/system/udp-bot.service
[Unit]
Description=UDP Bot Central V5
After=network.target
[Service]
User=root
WorkingDirectory=/etc/UDPCustom
ExecStart=/usr/bin/python3 /etc/UDPCustom/udp_bot.py
Restart=always
[Install]
WantedBy=multi-user.target
SERVICE_MARKER

  systemctl daemon-reload
  systemctl enable udp-bot
  systemctl restart udp-bot
  
  msg -verd " ‚úÖ Bot Central V5 (Licences + Passwords) Install√© !"
  msg -verd " ‚ÑπÔ∏è  Les autres VPS pourront v√©rifier les cl√©s sur http://$vps_ip:5000"
  enter
}

# 4. ONLINE USERS
online_pro() {
  title "üü¢ UTILISATEURS EN LIGNE"
  count=$(netstat -nulp | grep udp-custom | wc -l)
  msg -bar
  enter
}

# 5. SYST√àME DE LICENCE (DISTANT)
check_license() {
    if [[ -f "$LICENSE_FILE" ]]; then
        return 0
    fi
    title "üîí UDP CUSTOM PRO+"
    msg -verm " Cette section est verrouill√©e."
    msg -ama " Contactez @joeldata237 pour le code."
    msg -bar
    msg -ne " Entrez le Code : " && read key
    
    # V√©rification r√©elle via l'API du VPS Principal
    msg -azu " V√©rification sur le serveur central..."
    res=$(curl -s "$VERIFY_URL?key=$key")
    
    if [[ "$res" == "VALID" ]]; then
        msg -verd " ‚úÖ CODE VALIDE ! Bienvenue."
        touch "$LICENSE_FILE"
        sleep 2
        return 0
    else
        msg -verm " ‚ùå Code Invalide (ou Serveur injoignable)."
        sleep 2
        return 1
    fi
}

# ==================================================
#                  MENU PRINCIPAL
# ==================================================
udp() {
    title "JOEL DATA - UDP MANAGER V11"
    
    echo -e " \033[1;32m[1]\033[1;33m Cr√©er Utilisateur (Manuel)"
    echo -e " \033[1;32m[2]\033[1;33m Supprimer Utilisateur"
    echo -e " \033[1;32m[3]\033[1;33m Renouveler Utilisateur"
    echo -e " \033[1;32m[4]\033[1;33m Liste des Utilisateurs"
    echo -e " \033[1;32m[5]\033[1;33m Infos VPS (Neofetch)"
    
    if [[ -f "$LICENSE_FILE" ]]; then
        msg -bar2
        print_center -verd "--- OPTIONS PRO+ ---"
        echo -e " \033[1;36m[6]\033[1;37m INSTALLER BOT TELEGRAM V5 ü§ñ"
        echo -e " \033[1;36m[7]\033[1;37m Voir Utilisateurs En Ligne üü¢"
        echo -e " \033[1;31m[8]\033[1;37m Supprimer Licence"
    else
        msg -bar2
        echo -e " \033[1;31m[6]\033[1;33m UDP CUSTOM PRO+ (D√©bloquer) üîí"
    fi

    msg -bar
    echo -e " \033[1;31m[0]\033[1;37m Quitter"
    msg -bar
    
    read -p " S√©lection : " selection
    case $selection in
        1) add_user ;;
        2) remove_user ;;
        3) renew_user ;;
        4) list_users ;;
        5) neofetch; enter ;;
        6) 
            if [[ -f "$LICENSE_FILE" ]]; then install_bot_pro; else check_license && install_bot_pro; fi ;;
        7) 
            if [[ -f "$LICENSE_FILE" ]]; then online_pro; else check_license && online_pro; fi ;;
        8) 
            if [[ -f "$LICENSE_FILE" ]]; then rm "$LICENSE_FILE"; menu; fi ;;
            
        0) exit 0 ;;
        *) msg -verm "Option Invalide"; sleep 1; udp ;;
    esac
}

udp
